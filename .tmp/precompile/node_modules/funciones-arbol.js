var metadataSourceTable = [];
var metadataCategories = {};
var options;
var allmembername;
var container;
var varhst;

function newNode () {
    return { 
        "name":""
        , "value":0.0
        , "target":0.0
        , "avance":0.0
        , "category":""
        , "children":[]
        , "_children":[]
        , "serieColor":""
        };
}


function createSourceRowTree (sourceRow,metadataSourceTable) {
    var numCategories = 0,itemValue=0;itemTarget=0,itemAvance=0;
    for(var i=0; i<metadataSourceTable.length; i++){
        var columnInfo = metadataSourceTable[i];
        if (columnInfo.metadataType.toString().indexOf("Category")>-1) {
            numCategories++;
        }
        else if(columnInfo.metadataType.toString()=="measure"){
            itemValue=sourceRow[i];
        }
        else if(columnInfo.metadataType.toString()=="target")
        {
            itemTarget=sourceRow[i];
        }
        else if(columnInfo.metadataType.toString()=="avance")
        {
            itemAvance=sourceRow[i];
        }
    }
    var rowValue = itemValue;
    var rowTarget = itemTarget;
    var rowProgress = itemAvance;
    var retorno = { "name":allmembername, "value": rowValue, "target":rowTarget, "avance":rowProgress, "category":"Top Level", "children":[], "_children":[], serieColor:"" };
    var lastnode = retorno;
    var metadataColors = [];

    for(var i=0; i<numCategories; i++){
        //prevents nodes without sertie name (or null values)
        var singleNode = newNode();
        singleNode.value = rowValue;
        if (sourceRow[i]) singleNode.name = sourceRow[i];
        else singleNode.name="";
        singleNode.category = metadataSourceTable[i].columnName;
        if(!metadataColors[singleNode.category]){
            metadataColors[singleNode.category] = [];                
        }                
        if(!metadataColors[singleNode.category][singleNode.name]){
            metadataColors[singleNode.category][singleNode.name] = this.varhst.colorPalette.getColor(singleNode.name).value;
            
        }            
        singleNode.serieColor = metadataColors[singleNode.category][singleNode.name];
        
        
        singleNode.target = rowTarget;
        singleNode.avance = rowProgress;

        if (sourceRow[i]) {
            lastnode.children.push(singleNode);
            lastnode._children.push(singleNode);
            lastnode = lastnode.children[0];
            
        }
        

        
    }
    

    return retorno;

}


function fillTrees(sourceRowTree,sourceParsed) {

    var result={};
    // using jQuery extend
    //$.extend(result, sourceRowTree, sourceParsed);
    //result = merge(sourceRowTree,sourceParsed);
    var current = sourceRowTree;
    var currentParsed = sourceParsed;

    if (current.name == currentParsed.name) {
        if (sourceParsed.children.length == 0) {
            sourceParsed.children = current.children;
            //sourceParsed._children = current.children;
            sourceParsed.value += current.value;
            sourceParsed.target += current.target;
            //sourceParsed.avance = sourceParsed.avance > current.avance ? sourceParsed.avance : current.avance;
            if (current.avance) sourceParsed.avance = current.avance;
        }
        else {
            //sourceParsed.children.push(current.children[0]);
            var existe = false;
            for(var i=0;i<sourceParsed.children.length;i++){
                //sourceParsed.children[i] = fillTrees(sourceRowTree.children[0],sourceParsed.children[i]);
                if (sourceParsed.children[i].name == current.children[0].name) {
                    existe = true;
                    sourceParsed.children[i] = fillTrees(sourceRowTree.children[0],sourceParsed.children[i]);
                    //sourceParsed._children[i] = sourceParsed.children[i];
                }
            }
            if (!existe) {
                sourceParsed.children.push(current.children[0]);
                sourceParsed.value += current.value;
                sourceParsed.target += current.target;
                if (current.avance) sourceParsed.avance = current.avance;
                //sourceParsed.avance = sourceParsed.avance > current.avance ? sourceParsed.avance : current.avance;
                //sourceParsed._children.push(current.children[0]);
            }

        }

    }

    return sourceParsed;

}


function parseSourceTableRow(sourceRow,sourceParsed,metadataSourceTable) {

    var sourceRowTree = createSourceRowTree (sourceRow,metadataSourceTable);
    sourceParsed = fillTrees(sourceRowTree,sourceParsed);
    return sourceParsed;
}


function parseSource(source,metadataSourceTable){
    // init the return
    var sourceParsed = {"name":allmembername, "value":0.0, "target":0.0, "avance":0.0, "category":"Top Level", "children":[], "_children":[] };
    if (source != undefined) {
        if (source.rows != undefined){
            for(var i=0;i<source.rows.length;i++) {
                sourceParsed = parseSourceTableRow(source.rows[i],sourceParsed,metadataSourceTable);
            }
        }
    }

    // source.rows[i][0] ==> value
    // source.rows[i][1] ==> format value
    // source.rows[i][2] ==> first level
    // ...
    // source.rows[i][j] ==> level j
    sourceParsed = recalculateValues(sourceParsed);
    //recalculate values and targets

    return sourceParsed;
}

function recalculateValues(sourceParsed){
    var retorno=sourceParsed;
    if (retorno.children){
        if (retorno.children.length>0) {
            retorno.value=0;
            retorno.target=0;
            for(var i=0;i<retorno.children.length;i++){
                var child=recalculateValues(retorno.children[i]);
                if(child.value) retorno.value+= child.value;
                if(child.target) retorno.target+= child.target;
            }
        }

    } 
    return retorno;
}



function zoomed() {
    svg.selectAll("g").attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}


function inicializarArbol(h,w,source,hst){
    
    this.varhst = hst;
    var arcRadius = 15;
    try {
        arcRadius = parseInt(source.dataViews[0].metadata.objects["treeOptions"]["arcRadius"].toString());  
    } catch(e) {
        arcRadius = 15;
    }

    var nodeTextSize = 15;
    try {
        nodeTextSize = parseInt(source.dataViews[0].metadata.objects["treeOptions"]["nodeTextSize"].toString());  
    } catch(e) {
        nodeTextSize = 15;
    }

    var arcBaseColor = "lightsteelblue";
    try {
        arcBaseColor = source.dataViews[0].metadata.objects.treeOptions.arcBaseColor["solid"]["color"];
    } catch(e) {
        arcBaseColor = "lightsteelblue";
    }

    var linkColor = "lightgray";
    try {
        linkColor = source.dataViews[0].metadata.objects.treeOptions.linkColor["solid"]["color"];
    } catch(e) {
        linkColor = "lightgray";
    }

    var arcColorOK = "green";
    try {
        arcColorOK = source.dataViews[0].metadata.objects.treeOptions.arcCumplimientoOK["solid"]["color"];
    } catch(e) {
        arcColorOK = "green";
    }

    var arcColorKO = "red";
    try {
        arcColorKO = source.dataViews[0].metadata.objects.treeOptions.arcCumplimientoKO["solid"]["color"];
    } catch(e) {
        arcColorKO = "red";
    }

    var autoexpandtree;
    try {
        autoexpandtree = source.dataViews[0].metadata.objects["treeOptions"]["autoExpandTree"];         
    } catch(e) {
        autoexpandtree = true;
    }

    try {
        allmembername = source.dataViews[0].metadata.objects["treeOptions"]["allMemberName"].toString();                        
    } catch(e) {
        allmembername = "All";
    }

    var expandMode;
    try {
        expandMode = source.dataViews[0].metadata.objects["treeOptions"]["expandMode"];         
    } catch(e) {
        expandMode = true;
    }

    var weightLinks;
    try {
        weightLinks=source.dataViews[0].metadata.objects["treeOptions"]["weightLinks"];                
    
    } catch (e){
        weightLinks=true;
    }

    var magiclabels;
    try {
        magiclabels=source.dataViews[0].metadata.objects["treeOptions"]["magiclabels"];                
    
    } catch (e){
        magiclabels=false;
    }

    if (source){
        if (source.dataViews){
            if (source.dataViews[0]){
                if (source.dataViews[0].categorical){
                    if (source.dataViews[0].categorical.categories){
                        metadataCategories = source.dataViews[0].categorical.categories;
                    }
                }
            }
        }
    }

    
    var metadataColumns = {};
    //if (source.columns) columnMapping = mapColumns(source.columns);
    var settedMetadataSourceTable = false;
    var sourceTable = {};
    if (source.dataViews[0] != undefined){
        if (source.dataViews[0].table != undefined){
            sourceTable = source.dataViews[0].table;
        } else {
            //create table from categorical
            sourceTable={rows:[]};
            if (source.dataViews[0].categorical.categories){
                metadataSourceTable = [];
                    
                for(var i=0;i < source.dataViews[0].categorical.categories[0].values.length;i++){
                    var row = [];
                    for(var j=0;j<source.dataViews[0].categorical.categories.length;j++){
                        if(!settedMetadataSourceTable) {
                            var columnInfo = {"columnName":"", "metadataType":""};
                            columnInfo.columnName = source.dataViews[0].categorical.categories[j].source.displayName;
                            columnInfo.metadataType = "Category" + j.toString();
                            metadataSourceTable.push(columnInfo);
                        }
                        row.push(source.dataViews[0].categorical.categories[j].values[i]);
                    }
                    if (source.dataViews[0].categorical.values){
                        for(var j=0;j<source.dataViews[0].categorical.values.length;j++){
                            if(!settedMetadataSourceTable) {
                                var columnInfo = {"columnName":"", "metadataType":""};
                                columnInfo.columnName = source.dataViews[0].categorical.values[j].source.displayName;
                                if (source.dataViews[0].categorical.values[j].source.roles){
                                    if(source.dataViews[0].categorical.values[j].source.roles.measure) columnInfo.metadataType="measure";
                                    else if(source.dataViews[0].categorical.values[j].source.roles.target) columnInfo.metadataType="target";
                                    else if(source.dataViews[0].categorical.values[j].source.roles.avance) columnInfo.metadataType="avance";
                                    else columnInfo.metadataType="unknown";

                                }
                                metadataSourceTable.push(columnInfo);
                            }
                            row.push(source.dataViews[0].categorical.values[j].values[i]);
                        }
                        
                    }
                    settedMetadataSourceTable=true;
                    sourceTable.rows.push(row);
                }
            }
            
        }
        if (source.dataViews[0].metadata != undefined){
            if (source.dataViews[0].metadata.columns != undefined) {
                metadataColumns = source.dataViews[0].metadata.columns;
            }
        }
    }
    

    //var margin = {top: 20, right: 120, bottom: 20, left: 120},
    var margin = {top: 0, right: 0, bottom: 0, left: 90},
        width = w - margin.right - margin.left,
        height = h - margin.top - margin.bottom;

    var i = 0,
        duration = 750,
        root;
    
    var tree = d3.layout.tree()
        .size([height, width]);
        //.on("zoom", zoomed);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });
    
    var svg = d3.select("#div_arbol").append("svg")
        .attr("width", width + margin.right + margin.left+1000)
        .attr("height", height /*+ margin.top + margin.bottom*/)        
        .append("g")
        .attr("transform", "translate(" + margin.left + ",0)");
        //.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
       
    var sourceParsed = parseSource(sourceTable,metadataSourceTable);
    root = sourceParsed;
    root.x0 = height / 2;
    root.y0 = 0;
    
    update(root);
    
    d3.select(self.frameElement).style("height", "800px");

    function formatPercent(val){
        return (100*val).toFixed(2) + "%";
    }

    function formatPercentDiference(val){
        return (100*val).toFixed(2);
    }

    function formatValue(val){
        var retorno = "";

        var currentValue = val;        
        var numDigitos = parseFloat(currentValue.toFixed(2)).toLocaleString('es-ES').length;
        var numDivisiones = 0;
        
        while (numDigitos > 8) {
            numDivisiones++;
            currentValue = currentValue / 1000.00;
            numDigitos = parseFloat(currentValue.toFixed(2)).toLocaleString('es-ES').length;
        }

        var escala = "";
        switch(numDivisiones){
            case 0:
                escala = "";
                break;
            case 1:
                //miles
                escala = "k";
                break;
            case 2:
                //millones
                escala = "M";
                break;
            case 3:
                escala = "kM";
                break;
            case 4:
                escala = "B";
                break;
            case 5:
                escala = "kB";
                break;
            default:
                escala = " * 10e" + 3*numDivisiones;
        }

        retorno = parseFloat(currentValue.toFixed(2)).toLocaleString('es-ES') + " " + escala;

        return retorno;
    }

    function setText(d,textType) {
        var retorno = "";
        switch(textType){
            case "name":
                retorno = d.name;
            break;
            case "value":
                retorno = formatValue(d.value);
            break;
            case "target":
                retorno = formatPercent(d.value/d.target);
            break;
            case "avance":
                retorno = formatPercentDiference(d.value/d.target-d.avance);
            break;
            case "avance2":
                retorno = formatPercent(d.value/d.target);
            break;
        }        
        return retorno;
        //return d.category + ": " + d.name + ", Value: " + d.value.toLocaleString('es-ES');;
    }

    function update(source) {
        // Compute the new tree layout.
        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = [];
            }
        }

        function expandNodes(d){
            if (d._children.length > 0){
                d.children = d._children;
                d.children.forEach(expandNodes);
                d._children = [];
            }
        }
        
        if (autoexpandtree)
        //collapse(source);
        expandNodes(source);
        else
        collapse(source);

        
        var nodes = tree.nodes(source).reverse(),
            links = tree.links(nodes);
        updateGraph(nodes,source,this.varhst);
        
        
    }


    function getCumplimiento(d){
        var retorno = 0;
        var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
        var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
        var cumplimiento = 0;
        if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
        return retorno;
    }

    function getDiffCumplAvance(d) {
        var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
        var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
        var cumplimiento = 0;
        if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
        var avance = d.avance;
        if (!avance) avance = 0.0;
        var retorno = 0.0;
        var diff = cumplimiento-avance;
        diff < 0 ? retorno = cumplimiento : retorno = avance;
        //if (diff==0 || diff>1 || diff<-1) retorno = 1;
        if(diff>1 || diff<-1 )retorno = retorno - Math.abs(retorno);
        if (objetivo==0.0 && avance==0.0) retorno = 0;
        return 2*Math.PI*retorno;
    }

    function getDiffCumplAvanceEnd(d) {
        var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
        var valorPadre = 0.0;
        if (d.parent) valorPadre= isNaN(parseFloat(d.parent.value)) ? 0.0 : parseFloat(d.parent.value);
        var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
        var cumplimiento = 0;
        if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
        var avance = d.avance;
        if (!avance) avance = 0.0;
        var retorno = 0.0;
        var diff = cumplimiento-avance;
        diff > 0 ? retorno = cumplimiento : retorno = avance;
        if (diff==0 || diff>1 || diff<-1) retorno = 1;
        if (objetivo==0.0 && avance==0.0) retorno = 0;
        if ( avance==0 && objetivo==0 && valorPadre!=0) retorno = Math.abs(valor/valorPadre);
        
        return 2*Math.PI*retorno;
    }

    function updateGraph(nodes,source,varhost){
        var magiclabelsd = d3.selectAll("div")[0];
        magiclabelsd.forEach(function(d){
            debugger;
            if(d) if (d.id) if (d.id.indexOf('magiclabel')>-1) d.remove();
        });
        var links = tree.links(nodes);
        // Normalize for fixed-depth.
        nodes.forEach(function(d) { d.y = d.depth * 180; });

        // Update the nodes…
        var node = svg.selectAll("g.node")
            .data(nodes, function(d) { return d.id || (d.id = ++i); });

        var div_tooltip = d3.select("#div_arbol").append("div").attr("class", "tooltip").style("opacity", 0);

        //PROGRESS BAR
        /*
        if (nodes) if (nodes[0]) if (nodes[0].avance) {
            function progressCirclePosition(d){
                return "translate(0,50)";
            }
            var progressArc = d3.svg.arc().innerRadius(0).outerRadius(20).startAngle(0).endAngle(2*Math.PI*nodes[0].avance);
            svg.append("path").attr("d",progressArc ).attr("fill",arcBaseColor)
            .attr("transform", progressCirclePosition);            
            var progressCorona = d3.svg.arc().innerRadius(18).outerRadius(20).startAngle(0).endAngle(2*Math.PI);
            svg.append("path").attr("d",progressCorona ).attr("fill",arcBaseColor)
            .attr("transform", progressCirclePosition)           
            svg.append("text").attr('class', 'text-progress')
                    .text(formatPercent(nodes[0].avance))
                    .attr('x', 3)
                    .attr('y', 80);
            svg.append("text").attr('class', 'text-progress')
                .text("Progress")
                .attr('x', 0)
                .attr('y',25);    
        }
        */    

        // Enter any new nodes at the parent's previous position.
        
        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("click", click)
            .on("mouseover", function(d) {
                var htmlText = d.category + "<br/>" + d.name;
                if (d.value) htmlText += "<br/>Value: " + formatValue(d.value);
                if (d.target) htmlText += "<br/>Target: " + formatValue(d.target);
                
                div_tooltip.transition()		
                .duration(500)		
                .style("opacity", .9);		
                div_tooltip.html(htmlText)	
                .style("left", (d.y + arcRadius*5).toString() + "px")		
                .style("top", d.x + "px")
                	
            })
            .on("mouseout", function(d) {		
                div_tooltip.transition()		
                    .duration(100)		
                    .style("opacity", 0);	
            })
        ;

        var arcBlank = d3.svg.arc().innerRadius(0).outerRadius(arcRadius).startAngle(0)
        .endAngle(2*Math.PI);
        nodeEnter     
        .append("path").attr("d",arcBlank )        
        .style("fill", "white");

        var arcBase = d3.svg.arc().innerRadius(0).outerRadius(arcRadius).startAngle(0)
            .endAngle(getDiffCumplAvance);
        

        
        nodeEnter     
        .append("path").attr("d",arcBase )        
        .style("fill", function(d,i) {            
            return d._children ? arcBaseColor : "#fff"; 
        });
        var arc = d3.svg.arc().innerRadius(0).outerRadius(arcRadius)
        .startAngle(getDiffCumplAvance)
        .endAngle(getDiffCumplAvanceEnd);

        nodeEnter     
        .append("path").attr("d",arc )
        .style("fill", function(d,i) { 
            var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
            var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
            var cumplimiento = 0;
            if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
            var avance = d.avance;
            if (!avance) avance = 0.0;
            var retorno = arcBaseColor;
            if (avance != 0){
                var valor = cumplimiento - avance;
                if (valor > 0) retorno=arcColorOK; else if (valor<0) retorno=arcColorKO;
            }
            return retorno;
        });
        

        var arcCorona = d3.svg.arc().innerRadius(arcRadius-1).outerRadius(arcRadius)
        .startAngle(0)
        .endAngle(2*Math.PI);

        nodeEnter     
        .append("path").attr("d",arcCorona )
        .style("fill", arcBaseColor);
    
        //Node text name
        if(!magiclabels){
            nodeEnter.append("text")
                .attr("x", -10 - (arcRadius-8))
                .attr("dy", ".35em")
                //.attr("dy", function(d){return (d.source.y+d.target)})
                .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
                .text(function(d) { return setText(d,"name"); })
                .style("fill-opacity", 1)
                .style("font-size",nodeTextSize);
            
                
            //Node text value
            nodeEnter.append("text")
                .attr("x", function(d){
                    var name,len;
                    if (d.avance > 0){
                        name = setText(d,"avance2");                    
                    } else if (d.target > 0){
                        name = setText(d,"target");                    
                    } else {
                        name = setText(d,"value");
                    }
                    len = name.length;
                    //return 20+len*4+(arcRadius-8); 
                    return 20+len*4+(arcRadius+nodeTextSize); 
                })
                .attr("dy", "0.35em")
                .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
                .text(function(d){
                    var name="";
                    
                    if (d.avance > 0){
                        name = setText(d,"avance2");                    
                    } else if (d.target > 0){
                        name = setText(d,"target");                    
                    } else {
                        name = setText(d,"value");
                    }
                
                    return name; 
                })            
                .style("fill-opacity", 1)
                .style("font-size",nodeTextSize);
        }
        
        // Transition nodes to their new position.
        
        var nodeUpdate = node.transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
        
        nodeUpdate.select("text")
            .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();
   

        nodeExit.select("text")
            .style("fill-opacity", 1e-6);
        // Update the links…
        var link = svg.selectAll("path.link")
            .data(links, function(d) { return d.target.id; });
           
            
        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
            })
            .attr("style",function(d){
                var porc=2*arcRadius*Math.abs(d.target.value/d.target.parent.value);
                var colorLink = linkColor;
                if(weightLinks) {
                    if (d.target.serieColor) colorLink = d.target.serieColor;
                }
                var valor = 1.5;
                if(porc>1.5) valor = porc; 
                return "stroke-width:"+valor+"px;stroke:" + colorLink;
                
            })
            .on("click",function(d){
                try{
                    var basicFilter = {
                        $schema: "http://powerbi.com/product/schema#basic",
                        target: {
                        table: "Datos",
                        column: "Cowntry"
                        },
                        operator: "Equal",
                        values: ["Spain"],
                        filterType: "pbi.models.FilterType.BasicFilter"
                    }
                    varhost.applyJsonFilter(basicFilter,"general","filter");
                
                } catch(e){
                    var b = 0
                }
            })
            .on("mouseover", function(d){
                if(magiclabels){
                    var idlink = d.target.name;
                    var parent = d.target.parent;
                    var cont = false;
                    if (parent) cont=true;
                    while (cont){
                        if (parent){
                            idlink=parent.name+"-"+idlink;
                            parent = parent.parent;
                        } else {
                            cont=false;
                        }
                        if(parent) cont=false;
                    }
                    idlink="magiclabel-"+idlink;
                    
                    var labellink = d3.select("#"+idlink);
                    if (labellink[0][0]!=null){
                        labellink.remove();
                    } else {
                        labellink = d3.select("#div_arbol").append("div").attr("id",idlink).style("position","absolute" );
                        var htmlText = "<p class='magiclabels' style='font-size:" + nodeTextSize + "px'>"+d.target.name+"</p>";
                        labellink.html(htmlText)	
                        .style("left", (event.clientX).toString() + "px")		
                        .style("top", (event.clientY).toString() + "px")
                        .attr("class","magiclabels")
                        
                        
                    }
                     
                }
                
            })
            /*
            .on("mouseover", function(d) {
                var idlabel = d.source.name + "-" + d.target.name;
                
                var parent = d.source.parent;
                var cont = parent;
                while (cont){
                    if (parent) {
                        idlabel=parent.name+"-"+idlabel;
                        parent=parent.parent;
                    } else cont=false;
                }
                //var labellink = d3.select("#div_arbol").append("div").attr("class", "tooltip").style("opacity", 0);

                //debugger;
                var htmlText = d.target.category + "<br/>" + d.target.name;
                if (d.target.value) htmlText += "<br/>Value: " + formatValue(d.target.value);
                if (d.target.target) htmlText += "<br/>Target: " + formatValue(d.target.target);
                
                div_tooltip.transition()		
                .duration(500)		
                .style("opacity", .9);		
                div_tooltip.html(htmlText)	
                .style("left", ((d.target.y+d.source.y)/2 + arcRadius).toString() + "px")		
                .style("top", ((d.target.x+d.source.x)/2).toString() + "px")
                	
            })
            */
            /*
            .on("mouseout", function(d) {		
                div_tooltip.transition()		
                    .duration(100)		
                    .style("opacity", 0);	
            })
            */
        ;
        
        /*
        link.append("text")
            .attr("font-family", "Arial, Helvetica, sans-serif")
            .attr("fill", "Black")
            .style("font", "normal 12px Arial")
            .attr("transform", function(d) {
                return "translate(" +
                    ((d.source.y + d.target.y)/2) + "," + 
                    ((d.source.x + d.target.x)/2) + ")";
            })   
            //.attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .text(function(d) {
                return d.target.name;                
            });  
        */   
        
        // Transition links to their new position.
        link.transition()
            .duration(duration)
            .attr("d", diagonal);

        

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
            })
            .remove();

         
        // Stash the old positions for transition.
        nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    function updateClient(source){
        // Compute the new tree layout.
        
        var rootSource = source;
        while (rootSource.parent != undefined) {rootSource = rootSource.parent}
        
        var nodes = tree.nodes(rootSource).reverse(),
            links = tree.links(nodes);

        var parent = source;
        if (source.parent) {
            parent=source.parent;
            if (parent.parent) parent = parent.parent;
        }
        updateGraph(nodes,source,this.varhst);        
    }

    // Toggle children on click.
    function click(d) {
        if (d.children) {
            //collapse
            d._children = d.children;
            d.children = [];
        } else {
            // expand
            d.children = d._children;
            d._children = [];

            //collapse other nodes
            if (expandMode) {
                if (d.parent){
                    var parent = d.parent;
                    for(var i=0; i<parent.children.length; i++){
                        var currentNode = parent.children[i];
                        if (currentNode.id != d.id){
                            if (currentNode.children){
                                currentNode._children = currentNode.children;
                                currentNode.children = [];
                            }
                            
                        }
                    }
                }
            }
        }
        //update(d);
        //updateClient(d);
        var rootSource = d;
        while (rootSource.parent) {rootSource = rootSource.parent;};        
        var nodes = tree.nodes(rootSource).reverse();
        //var nodes = tree.nodes(d).reverse();
        var parent = d;
        if (d.parent) parent = d.parent;
        updateGraph(nodes,d,this.varhst);      
        //update(rootSource);
    }

}