var metadataSourceTable = [];
var metadataCategories = {};
var options;
var allmembername;
var container;
var varhst;

function newNode () {
    return { 
        "name":""
        , "value":0.0
        , "target":0.0
        , "avance":0.0
        , "category":""
        , "children":[]
        , "_children":[]
        , "serieColor":""
        };
}


function createSourceRowTree (sourceRow,metadataSourceTable) {
    //debugger;
    var numCategories = 0,itemValue=0;itemTarget=0,itemAvance=0;
    for(var i=0; i<metadataSourceTable.length; i++){
        var columnInfo = metadataSourceTable[i];
        if (columnInfo.metadataType.toString().indexOf("Category")>-1) {
            numCategories++;
        }
        else if(columnInfo.metadataType.toString()=="measure"){
            itemValue=sourceRow[i];
        }
        else if(columnInfo.metadataType.toString()=="target")
        {
            itemTarget=sourceRow[i];
        }
        else if(columnInfo.metadataType.toString()=="avance")
        {
            itemAvance=sourceRow[i];
        }
    }
    var rowValue = itemValue;
    var rowTarget = itemTarget;
    //debugger;
    var rowProgress = itemAvance;
    var retorno = { "name":allmembername, "value": rowValue, "target":rowTarget, "avance":rowProgress, "category":"Top Level", "children":[], "_children":[], serieColor:"" };
    var lastnode = retorno;
    for(var i=0; i<numCategories; i++){
        if (sourceRow[i]) {
            //prevents nodes without sertie name (or null values)
            var singleNode = newNode();
            singleNode.value = rowValue;
            singleNode.name = sourceRow[i];
            singleNode.serieColor = this.varhst.colorPalette.getColor(singleNode.name).value;
            singleNode.category = metadataSourceTable[i].columnName;
            singleNode.target = rowTarget;
            singleNode.avance = rowProgress;

            lastnode.children.push(singleNode);
            lastnode._children.push(singleNode);
            lastnode = lastnode.children[0];
        }

        
    }
    

    return retorno;

}


function fillTrees(sourceRowTree,sourceParsed) {

    var result={};
    // using jQuery extend
    //$.extend(result, sourceRowTree, sourceParsed);
    //result = merge(sourceRowTree,sourceParsed);
    var current = sourceRowTree;
    var currentParsed = sourceParsed;

    if (current.name == currentParsed.name) {
        if (sourceParsed.children.length == 0) {
            sourceParsed.children = current.children;
            //sourceParsed._children = current.children;
            sourceParsed.value += current.value;
            sourceParsed.target += current.target;
            //sourceParsed.avance = sourceParsed.avance > current.avance ? sourceParsed.avance : current.avance;
            if (current.avance) sourceParsed.avance = current.avance;
        }
        else {
            //sourceParsed.children.push(current.children[0]);
            var existe = false;
            for(var i=0;i<sourceParsed.children.length;i++){
                //sourceParsed.children[i] = fillTrees(sourceRowTree.children[0],sourceParsed.children[i]);
                if (sourceParsed.children[i].name == current.children[0].name) {
                    existe = true;
                    sourceParsed.children[i] = fillTrees(sourceRowTree.children[0],sourceParsed.children[i]);
                    //sourceParsed._children[i] = sourceParsed.children[i];
                }
            }
            if (!existe) {
                sourceParsed.children.push(current.children[0]);
                sourceParsed.value += current.value;
                sourceParsed.target += current.target;
                if (current.avance) sourceParsed.avance = current.avance;
                //sourceParsed.avance = sourceParsed.avance > current.avance ? sourceParsed.avance : current.avance;
                //sourceParsed._children.push(current.children[0]);
            }

        }

    }

    return sourceParsed;

}


function parseSourceTableRow(sourceRow,sourceParsed,metadataSourceTable) {

    // sourceRow[0] ==> value
    // sourceRow[1] ==> format value
    // sourceRow[2] ==> first level
    // ...
    // sourceRow[j] ==> level j

    var sourceRowTree = createSourceRowTree (sourceRow,metadataSourceTable);
    sourceParsed = fillTrees(sourceRowTree,sourceParsed);
    return sourceParsed;
}


function parseSource(source,metadataSourceTable){
    //debugger;
    // init the return
    var sourceParsed = {"name":allmembername, "value":0.0, "target":0.0, "avance":0.0, "category":"Top Level", "children":[], "_children":[] };
    if (source != undefined) {
        if (source.rows != undefined){
            for(var i=0;i<source.rows.length;i++) {
                sourceParsed = parseSourceTableRow(source.rows[i],sourceParsed,metadataSourceTable);
            }
        }
    }

    // source.rows[i][0] ==> value
    // source.rows[i][1] ==> format value
    // source.rows[i][2] ==> first level
    // ...
    // source.rows[i][j] ==> level j
    sourceParsed = recalculateValues(sourceParsed);
    //recalculate values and targets

    return sourceParsed;
}

function recalculateValues(sourceParsed){
    var retorno=sourceParsed;
    if (retorno.children){
        if (retorno.children.length>0) {
            retorno.value=0;
            retorno.target=0;
            for(var i=0;i<retorno.children.length;i++){
                var child=recalculateValues(retorno.children[i]);
                if(child.value) retorno.value+= child.value;
                if(child.target) retorno.target+= child.target;
            }
        }

    } 
    return retorno;
}



function zoomed() {
    debugger;
    svg.selectAll("g").attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}


function inicializarArbol(h,w,source,hst){
    this.varhst = hst;
    var arcRadius = 15;
    try {
        arcRadius = parseInt(source.dataViews[0].metadata.objects["treeOptions"]["arcRadius"].toString());  
    } catch(e) {
        arcRadius = 15;
    }

    //debugger;
    var arcBaseColor = "lightsteelblue";
    try {
        arcBaseColor = source.dataViews[0].metadata.objects.treeOptions.arcBaseColor["solid"]["color"];
    } catch(e) {
        arcBaseColor = "lightsteelblue";
    }

    var linkColor = "lightgray";
    try {
        linkColor = source.dataViews[0].metadata.objects.treeOptions.linkColor["solid"]["color"];
    } catch(e) {
        linkColor = "lightgray";
    }

    var arcColorOK = "green";
    try {
        arcColorOK = source.dataViews[0].metadata.objects.treeOptions.arcCumplimientoOK["solid"]["color"];
    } catch(e) {
        arcColorOK = "green";
    }

    var arcColorKO = "red";
    try {
        arcColorKO = source.dataViews[0].metadata.objects.treeOptions.arcCumplimientoKO["solid"]["color"];
    } catch(e) {
        arcColorKO = "red";
    }

    var autoexpandtree;
    try {
        //this.arcBaseColorStr = options.dataViews[0].metadata.objects.treeOptions.arcBaseColor.toString();
        //autoexpandtree = source.dataViews[0].metadata.objects["treeOptions"]["autoExpandTree"] == 'true';         
        autoexpandtree = source.dataViews[0].metadata.objects["treeOptions"]["autoExpandTree"];         
    } catch(e) {
        autoexpandtree = true;
    }

    //debugger;
    try {
        //this.arcBaseColorStr = options.dataViews[0].metadata.objects.treeOptions.arcBaseColor.toString();
        //autoexpandtree = source.dataViews[0].metadata.objects["treeOptions"]["autoExpandTree"] == 'true';         
        allmembername = source.dataViews[0].metadata.objects["treeOptions"]["allMemberName"].toString();                        
    } catch(e) {
        allmembername = "All";
    }

    var expandMode;
    try {
        //this.arcBaseColorStr = options.dataViews[0].metadata.objects.treeOptions.arcBaseColor.toString();
        //autoexpandtree = source.dataViews[0].metadata.objects["treeOptions"]["autoExpandTree"] == 'true';         
        expandMode = source.dataViews[0].metadata.objects["treeOptions"]["expandMode"];         
    } catch(e) {
        expandMode = true;
    }

    var weightLinks;
    try {
        weightLinks=source.dataViews[0].metadata.objects["treeOptions"]["weightLinks"];                
    
    } catch (e){
        weightLinks=true;
    }

    //debugger;
    if (source){
        if (source.dataViews){
            if (source.dataViews[0]){
                if (source.dataViews[0].categorical){
                    if (source.dataViews[0].categorical.categories){
                        metadataCategories = source.dataViews[0].categorical.categories;
                    }
                }
            }
        }
    }

    
    var metadataColumns = {};
    //if (source.columns) columnMapping = mapColumns(source.columns);
    var settedMetadataSourceTable = false;
    var sourceTable = {};
    if (source.dataViews[0] != undefined){
        if (source.dataViews[0].table != undefined){
            sourceTable = source.dataViews[0].table;
        } else {
            //create table from categorical
            sourceTable={rows:[]};
            if (source.dataViews[0].categorical.categories){
                metadataSourceTable = [];
                    
                for(var i=0;i < source.dataViews[0].categorical.categories[0].values.length;i++){
                    var row = [];
                    for(var j=0;j<source.dataViews[0].categorical.categories.length;j++){
                        //try{row.push(source.dataViews[0].categorical.categories[j].values[i]);}catch(e){}
                        //debugger;
                        if(!settedMetadataSourceTable) {
                            var columnInfo = {"columnName":"", "metadataType":""};
                            columnInfo.columnName = source.dataViews[0].categorical.categories[j].source.displayName;
                            columnInfo.metadataType = "Category" + j.toString();
                            metadataSourceTable.push(columnInfo);
                            //metadataSourceTable.push(source.dataViews[0].categorical.categories[j].source.displayName);
                        }
                        row.push(source.dataViews[0].categorical.categories[j].values[i]);
                    }
                    if (source.dataViews[0].categorical.values){
                        for(var j=0;j<source.dataViews[0].categorical.values.length;j++){
                            //try{row.push(source.dataViews[0].categorical.values[j].values[i]);}catch(e){}
                            //debugger;
                            if(!settedMetadataSourceTable) {
                                var columnInfo = {"columnName":"", "metadataType":""};
                                //debugger;

                                columnInfo.columnName = source.dataViews[0].categorical.values[j].source.displayName;
                                if (source.dataViews[0].categorical.values[j].source.roles){
                                    if(source.dataViews[0].categorical.values[j].source.roles.measure) columnInfo.metadataType="measure";
                                    else if(source.dataViews[0].categorical.values[j].source.roles.target) columnInfo.metadataType="target";
                                    else if(source.dataViews[0].categorical.values[j].source.roles.avance) columnInfo.metadataType="avance";
                                    else columnInfo.metadataType="unknown";

                                }
                                metadataSourceTable.push(columnInfo);
                                //metadataSourceTable.push(source.dataViews[0].categorical.values[j].source.displayName);
                            }
                            row.push(source.dataViews[0].categorical.values[j].values[i]);
                        }
                        
                    }
                    settedMetadataSourceTable=true;
                    sourceTable.rows.push(row);
                }
            }
            //debugger;
        }
        if (source.dataViews[0].metadata != undefined){
            if (source.dataViews[0].metadata.columns != undefined) {
                //debugger;
                metadataColumns = source.dataViews[0].metadata.columns;
            }
        }
    }
    

    //var margin = {top: 20, right: 120, bottom: 20, left: 120},
    var margin = {top: 10, right: 50, bottom: 10, left: 50},
        width = w - margin.right - margin.left,
        height = h - margin.top - margin.bottom;

    var i = 0,
        duration = 750,
        root;
    
    var tree = d3.layout.tree()
        .size([height, width]);
        //.on("zoom", zoomed);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });
    
    var svg = d3.select("#div_arbol").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)        
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    
    var sourceParsed = parseSource(sourceTable,metadataSourceTable);
    root = sourceParsed;
    root.x0 = height / 2;
    root.y0 = 0;
    
    update(root);
    
    d3.select(self.frameElement).style("height", "800px");

    function formatPercent(val){
        return (100*val).toFixed(2) + "%";
    }

    function formatPercentDiference(val){
        return (100*val).toFixed(2);
    }

    function formatValue(val){
        var retorno = "";

        var currentValue = val;        
        var numDigitos = parseFloat(currentValue.toFixed(2)).toLocaleString('es-ES').length;
        var numDivisiones = 0;
        
        while (numDigitos > 8) {
            numDivisiones++;
            currentValue = currentValue / 1000.00;
            numDigitos = parseFloat(currentValue.toFixed(2)).toLocaleString('es-ES').length;
        }

        var escala = "";
        switch(numDivisiones){
            case 0:
                escala = "";
                break;
            case 1:
                //miles
                escala = "k";
                break;
            case 2:
                //millones
                escala = "M";
                break;
            case 3:
                escala = "kM";
                break;
            case 4:
                escala = "B";
                break;
            case 5:
                escala = "kB";
                break;
            default:
                escala = " * 10e" + 3*numDivisiones;
        }

        retorno = parseFloat(currentValue.toFixed(2)).toLocaleString('es-ES') + " " + escala;

        return retorno;
    }

    function setText(d,textType) {
        var retorno = "";
        switch(textType){
            case "name":
                //retorno = d.category + ": " + d.name;
                retorno = d.name;
            break;
            case "value":
                //retorno = "Value: " + d.value.toLocaleString('es-ES');
                //retorno = "Value: " + formatValue(d.value);
                retorno = formatValue(d.value);
            break;
            case "target":
                //retorno = "Target: " + d.target.toLocaleString('es-ES');
                //retorno = "Target: " + formatValue(d.target);
                //retorno = "Completed: " + formatValue(100*d.value/d.target) + "%";
                retorno = formatPercent(d.value/d.target);
            break;
            case "avance":
                retorno = formatPercentDiference(d.value/d.target-d.avance);
            break;
        }        
        return retorno;
        //return d.category + ": " + d.name + ", Value: " + d.value.toLocaleString('es-ES');;
    }

    function update(source) {
        //debugger;
        // Compute the new tree layout.
        function collapse(d) {
            //debugger;
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = [];
            }
        }

        function expandNodes(d){
            if (d._children.length > 0){
                d.children = d._children;
                d.children.forEach(expandNodes);
                d._children = [];
            }
        }
        
        if (autoexpandtree)
        //collapse(source);
        expandNodes(source);
        else
        collapse(source);

        
        var nodes = tree.nodes(source).reverse(),
            links = tree.links(nodes);
        updateGraph(nodes,source);
        
        
    }


    function getCumplimiento(d){
        var retorno = 0;
        var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
        var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
        var cumplimiento = 0;
        if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
        return retorno;
    }

    function getDiffCumplAvance(d) {
        var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
        var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
        var cumplimiento = 0;
        if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
        var avance = d.avance;
        if (!avance) avance = 0.0;
        var retorno = 0.0;
        var diff = cumplimiento-avance;
        diff < 0 ? retorno = cumplimiento : retorno = avance;
        //if (diff==0 || diff>1 || diff<-1) retorno = 1;
        if(diff>1 || diff<-1 )retorno = retorno - Math.abs(retorno);
        if (objetivo==0.0 && avance==0.0) retorno = 0;
        return 2*Math.PI*retorno;
    }

    function getDiffCumplAvanceEnd(d) {
        var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
        var valorPadre = 0.0;
        if (d.parent) valorPadre= isNaN(parseFloat(d.parent.value)) ? 0.0 : parseFloat(d.parent.value);
        var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
        var cumplimiento = 0;
        if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
        var avance = d.avance;
        if (!avance) avance = 0.0;
        var retorno = 0.0;
        var diff = cumplimiento-avance;
        diff > 0 ? retorno = cumplimiento : retorno = avance;
        if (diff==0 || diff>1 || diff<-1) retorno = 1;
        if (objetivo==0.0 && avance==0.0) retorno = 0;
        //debugger;
        if ( avance==0 && objetivo==0 && valorPadre!=0) retorno = Math.abs(valor/valorPadre);
        
        return 2*Math.PI*retorno;
    }

    function updateGraph(nodes,source){
        var links = tree.links(nodes);
        // Normalize for fixed-depth.
        nodes.forEach(function(d) { d.y = d.depth * 180; });

        // Update the nodes…
        var node = svg.selectAll("g.node")
            .data(nodes, function(d) { return d.id || (d.id = ++i); });

        var div_tooltip = d3.select("#div_arbol").append("div").attr("class", "tooltip").style("opacity", 0);

        //PROGRESS BAR
        if (nodes) if (nodes[0]) if (nodes[0].avance) {

            
           
            function progressCirclePosition(d){
                return "translate(0,50)";
            }

            

            var progressArc = d3.svg.arc().innerRadius(0).outerRadius(20).startAngle(0).endAngle(2*Math.PI*nodes[0].avance);
            //progressCircle.transition().duration(1000).attr
            svg.append("path").attr("d",progressArc ).attr("fill",arcBaseColor)
            .attr("transform", progressCirclePosition);
            //.duration(750)
            //.attrTween("d", 10);

            var progressCorona = d3.svg.arc().innerRadius(18).outerRadius(20).startAngle(0).endAngle(2*Math.PI);
           //progressCircle.transition().duration(1000).attr
           svg.append("path").attr("d",progressCorona ).attr("fill",arcBaseColor)
           .attr("transform", progressCirclePosition)
           
           

           svg.append("text").attr('class', 'text-progress')
                //.attr('rx', 10)
                //.attr('ry', 10)
                .text(formatPercent(nodes[0].avance))
                .attr('x', 3)
                .attr('y', 80);
            svg.append("text").attr('class', 'text-progress')
                //.attr('rx', 10)
                //.attr('ry', 10)
                //.attr('text-align','center')
                //.attr('width', 200)
                .text("Progress")
                .attr('x', 0)
                .attr('y',25);
    
        }
    

        // Enter any new nodes at the parent's previous position.
        
        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("click", click)
            .on("mouseover", function(d) {
                var htmlText = d.category + "<br/>" + d.name;
                if (d.value) htmlText += "<br/>Value: " + formatValue(d.value);
                if (d.target) htmlText += "<br/>Target: " + formatValue(d.target);
                
                div_tooltip.transition()		
                .duration(500)		
                .style("opacity", .9);		
                div_tooltip.html(htmlText)	
                //.style("left", (d3.event.pageX) + "px")		
                .style("left", (d.y + arcRadius*5).toString() + "px")		
                .style("top", d.x + "px")
                //.attr("transform", translate(d.y , d.x ) )
                //.style("top", (d3.event.pageY - 28) + "px");	
            })
            .on("mouseout", function(d) {		
                div_tooltip.transition()		
                    .duration(100)		
                    .style("opacity", 0);	
            })
        ;

        var arcBlank = d3.svg.arc().innerRadius(0).outerRadius(arcRadius).startAngle(0)
        .endAngle(2*Math.PI);
        nodeEnter     
        .append("path").attr("d",arcBlank )        
        .style("fill", "white");

        var arcBase = d3.svg.arc().innerRadius(0).outerRadius(arcRadius).startAngle(0)
            .endAngle(getDiffCumplAvance);
        

        
        nodeEnter     
        .append("path").attr("d",arcBase )        
        .style("fill", function(d,i) {            
            return d._children ? arcBaseColor : "#fff"; 
        });
        var arc = d3.svg.arc().innerRadius(0).outerRadius(arcRadius)
        .startAngle(getDiffCumplAvance)
        .endAngle(getDiffCumplAvanceEnd);

        nodeEnter     
        .append("path").attr("d",arc )
        //.attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })        
        .style("fill", function(d,i) { 
            var valor = isNaN(parseFloat(d.value)) ? 0.0 : parseFloat(d.value);
            var objetivo = isNaN(parseFloat(d.target)) ? 0.0 : parseFloat(d.target);
            var cumplimiento = 0;
            if (objetivo != 0 && valor!=0) cumplimiento = valor / objetivo;
            var avance = d.avance;
            if (!avance) avance = 0.0;
            var retorno = arcBaseColor;
            if (avance != 0){
                var valor = cumplimiento - avance;
                if (valor > 0) retorno=arcColorOK; else if (valor<0) retorno=arcColorKO;
            }
            
            //return d._children ? "lightsteelblue" : "#fff"; 
            return retorno;
        });
        

        var arcCorona = d3.svg.arc().innerRadius(arcRadius-1).outerRadius(arcRadius)
        .startAngle(0)
        .endAngle(2*Math.PI);

        nodeEnter     
        .append("path").attr("d",arcCorona )
        .style("fill", arcBaseColor);
    
            
        
        nodeEnter.append("text")
            .attr("x", -10 - (arcRadius-8))
            .attr("dy", ".35em")
            //.attr("dy", function(d){return (d.source.y+d.target)})
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { return setText(d,"name"); })
            .style("fill-opacity", 1);
            

        nodeEnter.append("text")
            .attr("x", function(d){
                var name,len;
                if (d.avance > 0){
                    name = setText(d,"avance");                    
                } else if (d.target > 0){
                    name = setText(d,"target");                    
                } else {
                    name = setText(d,"value");
                }
                len = name.length;
                //return 20+len*4+(arcRadius-8); 
                return 20+len*4+(arcRadius); 
            })
            .attr("dy", "0.35em")
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d){
                var name="";
                
                if (d.avance > 0){
                    name = setText(d,"avance");                    
                } else if (d.target > 0){
                    name = setText(d,"target");                    
                } else {
                    name = setText(d,"value");
                }
            
                return name; 
            })            
            .style("fill-opacity", 1);

        
        // Transition nodes to their new position.
        
        var nodeUpdate = node.transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
        
        nodeUpdate.select("text")
            .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();
   

        nodeExit.select("text")
            .style("fill-opacity", 1e-6);
        //  debugger;
        // Update the links…
        var link = svg.selectAll("path.link")
            .data(links, function(d) { return d.target.id; });
           
            
        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
            })
            .attr("style",function(d){
                var porc=2*arcRadius*Math.abs(d.target.value/d.target.parent.value);
                var colorLink = linkColor;
                if(weightLinks) {
                    //colorLink = hst.colorPalette.getColor(d.target.name).value;
                    if (d.target.serieColor) colorLink = d.target.serieColor;
                }
                var valor = 1.5;
                if(porc>1.5) valor = porc; 
                //debugger;
                return "stroke-width:"+valor+"px;stroke:" + colorLink;
                //return "stroke-width:"+valor+"px;stroke:" + linkColor;
                //options.host.colorPalette.getColor("Spain")
            });
        
                  
        
        // Transition links to their new position.
        link.transition()
            .duration(duration)
            .attr("d", diagonal);
        

        

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
            })
            .remove();
        
        // Stash the old positions for transition.
        nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    function updateClient(source){
        // Compute the new tree layout.
        //debugger;
        var rootSource = source;
        while (rootSource.parent != undefined) {rootSource = rootSource.parent}
        
        var nodes = tree.nodes(rootSource).reverse(),
            links = tree.links(nodes);

        var parent = source;
        if (source.parent) {
            parent=source.parent;
            if (parent.parent) parent = parent.parent;
        }
        updateGraph(nodes,source);        
    }

    // Toggle children on click.
    function click(d) {
        //debugger;
        if (d.children) {
            //collapse
            d._children = d.children;
            d.children = [];
        } else {
            // expand
            d.children = d._children;
            d._children = [];

            //collapse other nodes
            //debugger;
            if (expandMode) {
                if (d.parent){
                    var parent = d.parent;
                    for(var i=0; i<parent.children.length; i++){
                        var currentNode = parent.children[i];
                        if (currentNode.id != d.id){
                            if (currentNode.children){
                                currentNode._children = currentNode.children;
                                currentNode.children = [];
                            }
                            
                        }
                    }
                }
            }
        }
        //update(d);
        //updateClient(d);
        var rootSource = d;
        while (rootSource.parent) {rootSource = rootSource.parent;};        
        var nodes = tree.nodes(rootSource).reverse();
        //var nodes = tree.nodes(d).reverse();
        //debugger;
        var parent = d;
        if (d.parent) parent = d.parent;
        updateGraph(nodes,d);      
        //update(rootSource);
    }

}